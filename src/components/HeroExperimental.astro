---
// Hero: Clean, focused with subtle depth
---

<section id="hero" class="hero-experimental">
  <!-- Background layers -->
  <div class="hero-bg">
    <!-- Video background -->
    <video
      autoplay
      muted
      loop
      playsinline
      preload="none"
      class="hero-video"
      poster="/images/hero-bg.jpg"
    >
      <source src="/videos/hero-bg.mp4" type="video/mp4" />
    </video>
    <div class="video-overlay"></div>

    <!-- Subtle grid pattern -->
    <div class="grid-pattern"></div>

    <!-- Gradient orbs - ambient light -->
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>

    <!-- Emergence ghosts - abstract forms using Ï† proportions -->
    <div class="ghost-layer">
      <!-- Ghost 1: Golden spiral (fibonacci) -->
      <svg class="ghost ghost-1" viewBox="0 0 144 89" preserveAspectRatio="xMidYMid meet">
        <path d="M 5 84
                 A 55 55 0 0 1 60 29
                 A 34 34 0 0 1 94 63
                 A 21 21 0 0 1 73 84
                 A 13 13 0 0 1 60 71
                 A 8 8 0 0 1 68 63"
              class="ghost-element ghost-curve" fill="none"/>
      </svg>

      <!-- Ghost 2: Nested golden rectangles -->
      <svg class="ghost ghost-2" viewBox="0 0 161.8 100" preserveAspectRatio="xMidYMid meet">
        <rect x="5" y="5" width="151.8" height="90" rx="2" class="ghost-element" fill="none"/>
        <rect x="5" y="5" width="93.8" height="90" rx="2" class="ghost-element" fill="none"/>
        <rect x="5" y="5" width="93.8" height="55.6" rx="2" class="ghost-element" fill="none"/>
      </svg>

      <!-- Ghost 3: Phi-spaced arcs (like ripples) -->
      <svg class="ghost ghost-3" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
        <circle cx="50" cy="50" r="8" class="ghost-element" fill="none"/>
        <circle cx="50" cy="50" r="13" class="ghost-element" fill="none"/>
        <circle cx="50" cy="50" r="21" class="ghost-element" fill="none"/>
        <circle cx="50" cy="50" r="34" class="ghost-element" fill="none"/>
      </svg>

      <!-- Ghost 4: Flowing phi curve -->
      <svg class="ghost ghost-4" viewBox="0 0 200 123.6" preserveAspectRatio="xMidYMid meet">
        <path d="M 10 61.8
                 Q 50 20, 100 61.8
                 T 190 61.8"
              class="ghost-element ghost-curve" fill="none"/>
        <path d="M 10 80
                 Q 62 40, 123.6 80"
              class="ghost-element ghost-curve" fill="none"/>
      </svg>

      <!-- Ghost 5: Torus cross-section -->
      <svg class="ghost ghost-5" viewBox="0 0 100 61.8" preserveAspectRatio="xMidYMid meet">
        <ellipse cx="50" cy="30.9" rx="45" ry="28" class="ghost-element" fill="none"/>
        <ellipse cx="50" cy="30.9" rx="17" ry="28" class="ghost-element" fill="none"/>
      </svg>

      <!-- Ghost 6: Vesica piscis (sacred geometry) -->
      <svg class="ghost ghost-6" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
        <circle cx="35" cy="50" r="30" class="ghost-element" fill="none"/>
        <circle cx="65" cy="50" r="30" class="ghost-element" fill="none"/>
      </svg>
    </div>
  </div>

  <!-- Main content -->
  <div class="hero-content">
    <div class="container">
      <!-- Title -->
      <h1 class="hero-title">
        <span class="title-line">
          <span class="word">Systems</span>
          <span class="dot">Â·</span>
          <span class="word">Intelligence</span>
          <span class="dot">Â·</span>
          <span class="word">Emergence</span>
        </span>
      </h1>

      <!-- Typewriter subtitle -->
      <p class="hero-subtitle">
        <span id="hero-typewriter-a" class="typewriter-text"></span>
        <span id="hero-typewriter-b" class="typewriter-text"></span>
        <span class="cursor">|</span>
      </p>

      <!-- Badges -->
      <div class="hero-badges">
        <span class="badge">
          <span class="badge-icon">âš¡</span>
          Distributed Systems
        </span>
        <span class="badge">
          <span class="badge-icon">ðŸ§ </span>
          AI Research
        </span>
        <span class="badge">
          <span class="badge-icon">ðŸŽµ</span>
          Music
        </span>
      </div>

      <!-- CTA buttons -->
      <div class="hero-cta">
        <a href="#explore" class="cta-primary">Explore My Work</a>
        <a href="/contact" class="cta-secondary">Get in Touch</a>
      </div>
    </div>
  </div>

  <!-- Scroll indicator -->
  <div class="scroll-indicator">
    <div class="scroll-mouse">
      <div class="scroll-wheel"></div>
    </div>
  </div>
</section>

<style>
  .hero-experimental {
    position: relative;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    background: #030712;
  }

  /* ========================================
     BACKGROUND
     ======================================== */
  .hero-bg {
    position: absolute;
    inset: 0;
  }

  .hero-video {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0.4;
    filter: saturate(1.1);
  }

  .video-overlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(
      180deg,
      rgba(3, 7, 18, 0.7) 0%,
      rgba(3, 7, 18, 0.4) 50%,
      rgba(3, 7, 18, 0.9) 100%
    );
  }

  /* Subtle grid pattern */
  .grid-pattern {
    position: absolute;
    inset: 0;
    background-image:
      linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
    background-size: 60px 60px;
    mask-image: radial-gradient(ellipse at center, black 20%, transparent 70%);
  }

  /* Ambient light orbs */
  .orb {
    position: absolute;
    border-radius: 50%;
    filter: blur(120px);
    opacity: 0.5;
    animation: orbFloat 20s ease-in-out infinite;
  }

  .orb-1 {
    width: 600px;
    height: 600px;
    top: -10%;
    left: -10%;
    background: radial-gradient(circle, rgba(14, 165, 233, 0.4) 0%, transparent 70%);
    animation-delay: 0s;
  }

  .orb-2 {
    width: 500px;
    height: 500px;
    bottom: -10%;
    right: -10%;
    background: radial-gradient(circle, rgba(168, 85, 247, 0.35) 0%, transparent 70%);
    animation-delay: -10s;
  }

  @keyframes orbFloat {
    0%, 100% { transform: translate(0, 0) scale(1); }
    33% { transform: translate(30px, -20px) scale(1.05); }
    66% { transform: translate(-20px, 30px) scale(0.95); }
  }

  /* ========================================
     EMERGENCE GHOSTS - Golden ratio forms
     ======================================== */
  .ghost-layer {
    position: absolute;
    inset: 0;
    pointer-events: none;
    overflow: hidden;
  }

  .ghost {
    position: absolute;
    opacity: 0;
    filter: blur(0.5px);
    animation: ghostEmerge var(--ghost-duration, 12s) ease-in-out infinite;
    animation-delay: var(--ghost-delay, 0s);
    transform-origin: center center;
    --ghost-scale: 1;
    --ghost-rotate: 0deg;
    --ghost-stroke: 1.5;
  }

  .ghost-element {
    stroke: rgba(255, 255, 255, 0.8);
    stroke-width: var(--ghost-stroke);
    fill: rgba(255, 255, 255, 0.03);
    stroke-dasharray: var(--dash-length, 1000);
    stroke-dashoffset: var(--dash-offset, 0);
    transition: stroke-dashoffset 2s ease-out;
  }

  .ghost-curve {
    stroke-width: calc(var(--ghost-stroke) * 1.3);
    fill: none;
  }

  .ghost.drawing .ghost-element {
    stroke-dashoffset: 0;
  }

  /* Rule of thirds positioning - abstract forms */
  .ghost-1 {
    /* Fibonacci spiral */
    width: 180px;
    height: 111px;
    top: 18%;
    left: 8%;
    transform: rotate(-15deg);
    --ghost-duration: 6s;
    --ghost-delay: 0s;
  }

  .ghost-2 {
    /* Golden rectangles */
    width: 140px;
    height: 86px;
    bottom: 25%;
    right: 12%;
    transform: rotate(8deg);
    --ghost-duration: 7s;
    --ghost-delay: -2s;
  }

  .ghost-3 {
    /* Phi-spaced circles */
    width: 120px;
    height: 120px;
    top: 55%;
    left: 5%;
    --ghost-duration: 5s;
    --ghost-delay: -1s;
  }

  .ghost-4 {
    /* Flowing curves */
    width: 200px;
    height: 124px;
    top: 12%;
    right: 20%;
    transform: rotate(-5deg);
    --ghost-duration: 8s;
    --ghost-delay: -4s;
  }

  .ghost-5 {
    /* Torus */
    width: 130px;
    height: 80px;
    bottom: 15%;
    left: 55%;
    transform: rotate(12deg);
    --ghost-duration: 6s;
    --ghost-delay: -3s;
  }

  .ghost-6 {
    /* Vesica piscis */
    width: 100px;
    height: 100px;
    top: 40%;
    right: 8%;
    --ghost-duration: 7s;
    --ghost-delay: -5s;
  }

  @keyframes ghostEmerge {
    0%, 100% {
      opacity: 0;
      transform: scale(calc(0.95 * var(--ghost-scale))) rotate(var(--ghost-rotate));
    }
    15%, 85% {
      opacity: 0;
    }
    35%, 65% {
      opacity: 0.18;
      transform: scale(var(--ghost-scale)) rotate(var(--ghost-rotate));
    }
    50% {
      opacity: 0.25;
      transform: scale(calc(1.02 * var(--ghost-scale))) rotate(var(--ghost-rotate));
    }
  }

  /* Variation for some ghosts */
  .ghost-2, .ghost-5 {
    animation-name: ghostEmerge2;
  }

  @keyframes ghostEmerge2 {
    0%, 100% {
      opacity: 0;
      transform: scale(calc(0.94 * var(--ghost-scale))) rotate(var(--ghost-rotate));
    }
    20%, 80% {
      opacity: 0;
    }
    40%, 60% {
      opacity: 0.15;
      transform: scale(var(--ghost-scale)) rotate(var(--ghost-rotate));
    }
    50% {
      opacity: 0.22;
      transform: scale(calc(1.01 * var(--ghost-scale))) rotate(var(--ghost-rotate));
    }
  }

  /* Slightly different timing for vesica */
  .ghost-6 {
    animation-name: ghostEmerge3;
  }

  @keyframes ghostEmerge3 {
    0%, 100% {
      opacity: 0;
      transform: scale(calc(0.96 * var(--ghost-scale))) rotate(var(--ghost-rotate));
    }
    25%, 75% {
      opacity: 0;
    }
    45%, 55% {
      opacity: 0.15;
      transform: scale(var(--ghost-scale)) rotate(var(--ghost-rotate));
    }
    50% {
      opacity: 0.2;
      transform: scale(calc(1.01 * var(--ghost-scale))) rotate(var(--ghost-rotate));
    }
  }

  /* ========================================
     CONTENT
     ======================================== */
  .hero-content {
    position: relative;
    z-index: 10;
    width: 100%;
    padding: 120px 24px 80px;
    text-align: center;
  }

  /* Title */
  .hero-title {
    margin: 0 0 24px;
    font-size: clamp(2.5rem, 7vw, 5rem);
    font-weight: 800;
    line-height: 1.1;
  }

  .title-line {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 0.3em;
  }

  .word {
    color: white;
    display: inline-block;
    opacity: 0;
    transform: translateY(30px);
    animation: wordReveal 0.7s cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  .word:nth-child(1) { animation-delay: 0.1s; }
  .word:nth-child(3) { animation-delay: 0.2s; }
  .word:nth-child(5) { animation-delay: 0.3s; }

  @keyframes wordReveal {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .dot {
    color: rgba(255, 255, 255, 0.2);
    font-weight: 300;
    opacity: 0;
    animation: fadeIn 0.5s ease forwards 0.5s;
  }

  @keyframes fadeIn {
    to { opacity: 1; }
  }

  /* Subtitle */
  .hero-subtitle {
    font-size: clamp(0.95rem, 2.2vw, 1.25rem);
    color: rgba(255, 255, 255, 0.7);
    height: 3.5em;
    margin: 0 auto 40px;
    max-width: 700px;
    font-family: ui-monospace, 'SF Mono', monospace;
    position: relative;
    perspective: 500px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .typewriter-text {
    color: rgba(255, 255, 255, 0.85);
    display: inline-block;
    position: absolute;
    transition: opacity 2.5s ease-out, transform 2.5s ease-out;
  }

  .typewriter-text.dissipate {
    opacity: 0;
    transform: translateY(-8px);
  }

  .typewriter-text.typing {
    opacity: 1;
    transform: translateY(0);
  }

  .cursor {
    color: #0ea5e9;
    animation: blink 1s step-end infinite;
  }

  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }

  /* Badges */
  .hero-badges {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 12px;
    margin-bottom: 40px;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 100px;
    color: rgba(255, 255, 255, 0.8);
    font-size: 0.9rem;
    font-weight: 500;
    opacity: 0;
    transform: translateY(15px);
    animation: badgeReveal 0.5s ease forwards;
    transition: all 0.2s ease;
  }

  .badge:nth-child(1) { animation-delay: 0.6s; }
  .badge:nth-child(2) { animation-delay: 0.7s; }
  .badge:nth-child(3) { animation-delay: 0.8s; }

  @keyframes badgeReveal {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .badge:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.2);
  }

  .badge-icon {
    font-size: 1rem;
  }

  /* CTA */
  .hero-cta {
    display: flex;
    justify-content: center;
    gap: 16px;
    flex-wrap: wrap;
  }

  .cta-primary,
  .cta-secondary {
    padding: 14px 28px;
    border-radius: 10px;
    font-weight: 600;
    font-size: 0.95rem;
    text-decoration: none;
    transition: all 0.2s ease;
  }

  .cta-primary {
    background: white;
    color: #030712;
  }

  .cta-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(255, 255, 255, 0.2);
  }

  .cta-secondary {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.15);
    color: white;
  }

  .cta-secondary:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.25);
  }

  /* Scroll indicator */
  .scroll-indicator {
    position: absolute;
    bottom: 32px;
    left: 50%;
    transform: translateX(-50%);
    opacity: 0;
    animation: fadeIn 1s ease forwards 2s;
  }

  .scroll-mouse {
    width: 24px;
    height: 38px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    position: relative;
  }

  .scroll-wheel {
    width: 4px;
    height: 8px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 2px;
    position: absolute;
    top: 6px;
    left: 50%;
    transform: translateX(-50%);
    animation: scrollWheel 2s ease-in-out infinite;
  }

  @keyframes scrollWheel {
    0%, 100% { opacity: 1; transform: translateX(-50%) translateY(0); }
    50% { opacity: 0.3; transform: translateX(-50%) translateY(10px); }
  }

  /* ========================================
     RESPONSIVE
     ======================================== */
  @media (max-width: 768px) {
    .title-line {
      flex-direction: column;
      gap: 4px;
    }

    .dot {
      display: none;
    }

    .hero-badges {
      gap: 8px;
    }

    .badge {
      padding: 8px 14px;
      font-size: 0.85rem;
    }

    .hero-cta {
      flex-direction: column;
      align-items: center;
    }

    .cta-primary,
    .cta-secondary {
      width: 100%;
      max-width: 260px;
      text-align: center;
    }
  }

  /* ========================================
     REDUCED MOTION
     ======================================== */
  @media (prefers-reduced-motion: reduce) {
    .orb { animation: none; }
    .ghost { animation: none; opacity: 0; }
    .word, .badge { animation: none; opacity: 1; transform: none; }
    .scroll-wheel { animation: none; }
  }

  /* Hide ghosts on mobile for performance */
  @media (max-width: 768px) {
    .ghost-layer {
      display: none;
    }
  }
</style>

<script>
  // Typewriter that breathes like thought
  class Typewriter {
    private thoughts = [
      { text: "I build systems that argue with themselves until something useful emerges.", pace: 1, linger: 1.2 },
      { text: "93% on ARC. No transformers. Just shapes talking to shapes.", pace: 0.9, linger: 1.4 },
      { text: "Debugging COBOL at 22. Debugging reality at 37.", pace: 1.1, linger: 1 },
      { text: "The best architectures are the ones that surprise their architects.", pace: 0.85, linger: 1.3 },
      { text: "Patterns emerge when you stop forcing them.", pace: 1.2, linger: 0.9 },
      { text: "Every bug is a lesson in humility.", pace: 1, linger: 1.1 },
      { text: "The code writes back if you listen.", pace: 0.95, linger: 1.5 },
      { text: "Complexity hides in the spaces between simple things.", pace: 0.8, linger: 1.2 }
    ];

    private elA: HTMLElement | null;
    private elB: HTMLElement | null;
    private activeEl: HTMLElement | null;
    private index = 0;

    constructor(idA: string, idB: string) {
      this.elA = document.getElementById(idA);
      this.elB = document.getElementById(idB);
      this.activeEl = this.elA;
    }

    private delay(ms: number): Promise<void> {
      return new Promise(r => setTimeout(r, ms));
    }

    private getInactiveEl(): HTMLElement | null {
      return this.activeEl === this.elA ? this.elB : this.elA;
    }

    // Organic timing - like breathing
    private getCharDelay(char: string, pace: number): number {
      const base = 45 * pace;

      // Punctuation = longer pause (thinking)
      if (char === '.') return 350 * pace;
      if (char === ',') return 180 * pace;
      if (char === 'â€”' || char === '-') return 220 * pace;

      // Spaces = brief pause
      if (char === ' ') return 70 * pace;

      // Regular characters with slight variation
      return base + Math.random() * 25;
    }

    // Occasional thinking pauses mid-sentence
    private shouldPause(): boolean {
      return Math.random() < 0.03; // 3% chance
    }

    private async type(): Promise<void> {
      if (!this.activeEl) return;

      const thought = this.thoughts[this.index];
      let text = "";

      // Prepare - start invisible
      this.activeEl.classList.remove('dissipate', 'typing');
      this.activeEl.textContent = "";
      this.activeEl.style.opacity = '0';
      void this.activeEl.offsetWidth;

      // Fade in as we start typing
      this.activeEl.classList.add('typing');

      // Type with organic rhythm
      for (let i = 0; i < thought.text.length; i++) {
        if (!this.activeEl) return;

        const char = thought.text[i];
        text += char;
        this.activeEl.textContent = text;

        // Wait based on character and pace
        await this.delay(this.getCharDelay(char, thought.pace));

        // Occasional thinking pause (not at start or end)
        if (i > 5 && i < thought.text.length - 5 && this.shouldPause()) {
          await this.delay(400 + Math.random() * 300);
        }
      }

      // Linger - variable based on thought
      const lingerTime = 2400 * thought.linger;
      await this.delay(lingerTime);

      // Begin fade out
      this.activeEl.classList.remove('typing');
      this.activeEl.classList.add('dissipate');

      // Wait a bit, then start next thought (overlap)
      await this.delay(1200);

      // Swap to other element
      const fadingEl = this.activeEl;
      this.activeEl = this.getInactiveEl();
      this.index = (this.index + 1) % this.thoughts.length;

      // Clean up after fade completes
      setTimeout(() => {
        if (fadingEl) {
          fadingEl.textContent = "";
          fadingEl.classList.remove('dissipate', 'typing');
        }
      }, 2500);
    }

    async start(): Promise<void> {
      // Initial pause before first thought
      await this.delay(1200);
      while (true) await this.type();
    }
  }

  new Typewriter('hero-typewriter-a', 'hero-typewriter-b').start();

  // Smooth scroll
  document.querySelector('.cta-primary')?.addEventListener('click', (e) => {
    e.preventDefault();
    document.querySelector('#explore')?.scrollIntoView({ behavior: 'smooth' });
  });

  // Ghost randomization - each emergence is unique
  class GhostRandomizer {
    private ghosts: NodeListOf<HTMLElement>;
    private durations: number[] = [6, 7, 5, 8, 6, 7]; // seconds per ghost

    constructor() {
      this.ghosts = document.querySelectorAll('.ghost') as NodeListOf<HTMLElement>;
      this.init();
    }

    private randomRange(min: number, max: number): number {
      return min + Math.random() * (max - min);
    }

    private randomize(ghost: HTMLElement): void {
      // Random scale: 0.7 to 1.4
      const scale = this.randomRange(0.7, 1.4);

      // Random rotation: -30 to +30 degrees from base
      const rotate = this.randomRange(-30, 30);

      // Random stroke width: 1 to 3
      const stroke = this.randomRange(1, 3);

      // Random position offset: -15% to +15%
      const offsetX = this.randomRange(-15, 15);
      const offsetY = this.randomRange(-15, 15);

      ghost.style.setProperty('--ghost-scale', scale.toString());
      ghost.style.setProperty('--ghost-rotate', `${rotate}deg`);
      ghost.style.setProperty('--ghost-stroke', stroke.toString());
      ghost.style.transform = `translate(${offsetX}%, ${offsetY}%)`;

      // Drawing effect - set initial dashoffset
      const elements = ghost.querySelectorAll('.ghost-element') as NodeListOf<SVGElement>;
      elements.forEach(el => {
        const length = this.getPathLength(el);
        el.style.setProperty('--dash-length', length.toString());
        el.style.setProperty('--dash-offset', length.toString());
      });

      // Trigger drawing animation
      ghost.classList.remove('drawing');
      void ghost.offsetWidth; // Force reflow
      ghost.classList.add('drawing');
    }

    private getPathLength(el: SVGElement): number {
      if (el instanceof SVGPathElement) {
        return el.getTotalLength();
      } else if (el instanceof SVGCircleElement) {
        const r = parseFloat(el.getAttribute('r') || '0');
        return 2 * Math.PI * r;
      } else if (el instanceof SVGEllipseElement) {
        const rx = parseFloat(el.getAttribute('rx') || '0');
        const ry = parseFloat(el.getAttribute('ry') || '0');
        // Approximation for ellipse circumference
        return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
      } else if (el instanceof SVGRectElement) {
        const w = parseFloat(el.getAttribute('width') || '0');
        const h = parseFloat(el.getAttribute('height') || '0');
        return 2 * (w + h);
      }
      return 500; // fallback
    }

    private init(): void {
      // Randomize each ghost on its animation cycle
      this.ghosts.forEach((ghost, index) => {
        const duration = this.durations[index] * 1000;

        // Initial randomization
        this.randomize(ghost);

        // Re-randomize at each cycle
        setInterval(() => {
          this.randomize(ghost);
        }, duration);
      });
    }
  }

  // Start ghost randomization
  if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    new GhostRandomizer();
  }
</script>
